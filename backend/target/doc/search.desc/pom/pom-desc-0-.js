searchState.loadedDescShard("pom", 0, "Wrap &amp;u8 or &amp;char as input to parser.\nContains the error value\nParser error.\nParser input is generic over terminal type, which is …\nContains the success value\nParser type, <code>Parser&lt;I, O&gt;</code> is alias of …\nParser result, <code>Result&lt;O&gt;</code> ia alias of <code>Result&lt;O, pom::Error&gt;</code>.\nWrap &amp;str as input to parser.\nA train is a series of knots, each knot can be a terminal …\nAdvance to next symbol.\nUtility functions to recognize char class of byte value.\nPeek current symbol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJump to specified position.\nConstains predefined parsers and combinators.\nGet current position.\nGet a segment from the input.\nRecognises an alphabetic character, <code>a-zA-Z</code>.\nRecognises an alphanumeric character, <code>a-zA-Z0-9</code>.\nRecognises a decimal digit, <code>0-9</code>.\nRecognises a hexadecimal digit, <code>0-9a-fA-F</code>.\nRecognises a space, tab, line feed, or carriage return.\nRecognises an octal digit, <code>0-7</code>.\nRecognises a space or tab.\nParser combinator.\nCall a parser factory, can be used to create recursive …\nCollect all matched input symbols.\nConvert parser result to desired value, fail in case of …\nDiscard parser output.\nAlways succeeds, consume no input.\nSuccess when end of input is reached.\nMark parser as expected, abort early when failed in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSuccess when predicate returns true on current input …\nParse separated list.\nConvert parser result to desired value.\nGive parser a name to identify parsing errors.\nCreate new parser.\nSuccess when current input symbol is none of the set.\nSuccess when predicate returns false on current input …\nSuccess when current input symbol is one of the set.\nMake parser optional.\nApply the parser to parse input.\nGet input position after matching parser.\n<code>p.repeat(5)</code> repeat p exactly 5 times <code>p.repeat(0..)</code> repeat …\nSuccess when sequence of symbols matches current input.\nSkip n symbols.\nSuccess when current input symbol equals <code>t</code>.\nRead n symbols.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSet relationship.\nWhether a set contains an element or not.\nConvert to text for display.")